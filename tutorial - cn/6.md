
## 6. 地形影响
  - [地形类型](#地形类型)
  - [疲劳度计算](#疲劳度计算)
  - [溢出转移](#溢出转移)
  - [最终代码](#最终代码)

在本节教程中，会教会您关于不同地形对移动的影响。

### 地形类型

在现有的任意地图中(截止到1.0游戏版本)都有3种地形：

| 地形 | 类型 | 值 | 移动消耗 | 描述 |
|------|------|------|----------|------|
| TERRAIN_WALL | str | "terrain_wall" | 255 | 不可被破坏的可以阻挡Creep移动到此处的地形。 |
| TERRAIN_SWAMP | str | "terrain_swamp" | 10 | 沼泽地形。 |
| TERRAIN_PLAIN | str | "terrain_plain" | 2 | 平坦地形。 |

* 除了地形之外，大部分建筑物会阻挡移动。只有下面的几种可以通行:

| 建筑 | 等效移动消耗 | 描述 |
|------|--------------|------|
| StructureRampart | (己方)不变/(敌方)255 | 己方Creep可以通过。 |
| StructureContainer | 不变 | 不会阻挡creep通过。 |
| StructureRoad | 1 | 将移动消耗降低至1，不论先前的地形是`PLAIN`还是`SWAMP`。 |

### 疲劳度计算

当一个Creep移动到某个可通过的地形上时，它会获得疲劳度`fatigue`，其数值由两部分组成:
* Creep中非MOVE且非CARRY的组件的数量，记做`mc`；Creep中Carry且携带资源的组件数量，计做`rc`
* 移动到的地形的`移动消耗`值，比如TERRAIN_SWAMP的值为10。

该Creep移动到该地形后，获得`(mc + rc) * 移动消耗`数目的`fatigue`值。在MOVE组件消除完所有疲劳度前，Creep便无法继续移动。

### 溢出转移

前面讲过，当一个Creep的MOVE组件将`fatigue`值降低到<0时，实际会被限制到0。即便某个tick时，Creep并未移动，且其`fatigue`值为0，MOVE组件仍然会工作。这部分溢出值可以被转移到相邻的Creep身上，称为`溢出转移`。

#### 溢出转移: 推动指令

一个高移动力的Creep可以`推动`一个低移动力的Creep(但必须有至少一个正常工作的MOVE组件)。前者溢出的部分可以传递给后者。

推动指令(`push`)是`Creep`类的一个的实例方法，构造如下:

| 参数名 | 类型 | 可选 | 默认值 | 描述 |
|--------|------|------|--------|------|
| `target` | `Creep` | 否 | - | 被推动的目标 |
| `options` | `UsrObject` \| `None` | 是 | `None` | 移动选项，仅在二者距离超过1时有效。如果为 `None`，则使用默认的移动选项。 |

**返回值**：错误码
- `OK` (0): 操作成功
- `ERR_NOT_OWNER` (-1): 非 Creep 拥有者
- `ERR_INVALID_ARGS` (-10): 参数不正确
- `ERR_NO_BODYPART` (-12): 无 MOVE 部件

```python
from builtin import *

c0 = get.creep(5, 5)  # 获得位于坐标(5, 5)处的Creep，假设其recipe为MM
c1 = get.creep(8, 6)  # 获得位于坐标(8, 6)处的Creep，假设其recipe为MAAA

c0.push(c1)  # c0本身不产生fatigue，因此可以把溢出值传递给c1。
c1.move(Point(20, 20))  # 假设地图均为TERRAIN_PLAIN，产生(3+0)*2=6点疲劳度
```

#### 溢出转移: 拉动指令

一个高移动力的Creep可以`拉动`一个低移动力的Creep(目标可以没有MOVE组件)向自己移动。前者溢出的部分可以传递给后者。

拉动指令(`pull`)是`Creep`类的一个的实例方法，构造如下:

| 参数名 | 类型 | 可选 | 默认值 | 描述 |
|--------|------|------|--------|------|
| `target` | `Creep` | 否 | - | 被拉动的目标 |
| `options` | `UsrObject` \| `None` | 是 | `None` | 移动选项，仅在二者距离超过1时有效。如果为 `None`，则使用默认的移动选项。 |


**返回值**：错误码
- `OK` (0): 操作成功
- `ERR_NOT_OWNER` (-1): 非 Creep 拥有者
- `ERR_INVALID_ARGS` (-10): 参数不正确
- `ERR_NO_BODYPART` (-12): 无 MOVE 部件

```python
from builtin import *

c0 = get.creep(5, 5)  # 获得位于坐标(5, 5)处的Creep，假设其recipe为MM
c1 = get.creep(8, 6)  # 获得位于坐标(8, 6)处的Creep，假设其recipe为AA

c0.pull(c1)  # c0本身不产生fatigue，因此可以把溢出值传递给c1。
c0.move(Point(20, 20))  # 注意和push的区别，此处是c0拉着c1移动(c0在前，c1在后)
```

### 最终代码

```python
from builtin import *

CREEPS = get.creeps()

def init(k: GlobalKnowledge):
    pass


def step(k: GlobalKnowledge):
    for c in CREEPS:
        c.move(RIGHT)

```



