## 事件系统
- [事件概述](#事件概述)
- [使用std静态方法](#使用std静态方法)
- [使用Creep实例方法](#使用creep实例方法)
- [使用Stage实例方法](#使用stage实例方法)
- [@listen装饰器](#listen装饰器)
- [事件匹配规则](#事件匹配规则)
- [事件数据格式](#事件数据格式)
- [最终代码](#最终代码)
### 事件概述

事件系统基于发布-订阅模式，包含三个核心操作：

1. **监听事件** - 注册对特定事件的兴趣
2. **推送事件** - 触发事件并通知所有监听者
3. **取消监听** - 移除事件监听

系统提供两种使用方式：
- `std` 模块的静态方法 - 全局事件管理
- `Stage` 及其子类的实例方法 - 对象级事件管理
- `@listen` 装饰器 - 声明式事件监听

### 使用std静态方法

`std` 模块提供了三个静态方法用于事件操作：

#### std.listenFor

注册全局事件监听器。

| 参数名 | 类型 | 可选 | 默认值 | 描述 |
|-------|------|------|--------|------|
| `event_name` | `str` | 否 | - | 事件名称 |
| `func` | `callable` | 否 | - | 事件触发时调用的回调函数 |
| `*sources` | `str` | 是 | `[]` | 事件来源过滤器，只监听来自这些源的事件 |

**示例**：监听所有名为"resource_depleted"的事件

```python
from builtin import *

def on_resource_depleted(data):
    print(f"[DEBUG] 资源耗尽: {data}")  # 调试输出：查看事件数据

std.listenFor("resource_depleted", on_resource_depleted)
```

#### std.pushEvent

触发全局事件。

| 参数名 | 类型 | 可选 | 默认值 | 描述 |
|-------|------|------|--------|------|
| `event_name` | `str` | 否 | - | 事件名称 |
| `data` | `any` | 是 | `None` | 事件数据，会传递给所有监听者 |
| `*targets` | `str` | 是 | `[]` | 事件目标过滤器，只通知这些目标的监听者 |

**示例**：触发"resource_depleted"事件

```python
std.pushEvent("resource_depleted", {"source_id": "source1", "position": Point(10, 10)})
```

#### std.cancelEvent

取消全局事件监听。

| 参数名 | 类型 | 可选 | 默认值 | 描述 |
|-------|------|------|--------|------|
| `event_name` | `str` | 否 | - | 要取消监听的事件名称 |

**示例**：取消对"resource_depleted"事件的监听

```python
std.cancelEvent("resource_depleted")
```


### 使用Creep实例方法

所有在游戏中获取到的Creep示例都拥有以下事件方法：
 - `listenFor(event_name: str, func: callable, *sources: str)`
 - `pushEvent(event_name: str, data: any, *targets: str)`
 - `cancelEvent(event_name: str)`

**注意**: 和std的参数形式一致，但需要通过Creep实例来调用。

### 使用Stage实例方法

所有继承自 `Stage` 及其子类（如 `CreepLogic`、`Logic`）的实例都拥有以下事件方法：
 - `listenFor(event_name: str, func: callable, *sources: str)`
 - `pushEvent(event_name: str, data: any, *targets: str)`
 - `cancelEvent(event_name: str)`
  
**注意**: 和std的参数形式一致，不过只能在类实例方法中使用。

### @listen装饰器

`@listen` 装饰器提供声明式的事件监听注册方式。

**语法**：
```python
@listen(event_name: str, *sources: str)
```

**注意**：只能用于Stage及其子类的实例方法，不能用于独立的函数或其他类的方法。

**示例**：使用装饰器注册事件监听

```python
from builtin import *

class SmartMinerCreep(CreepLogic):
    NAME = "SmartMiner"
    
    @listen("source_empty")
    def handle_source_empty(self, data):
        """当source耗尽时自动调用"""
        print(f"[DEBUG] {self.name} 通过装饰器收到 source_empty 事件")  # 调试输出：确认装饰器生效
        self.transform("FindNewSource")
```
### 事件匹配规则

事件系统支持灵活的匹配机制：

#### 来源过滤

在注册监听时指定 `sources` 参数，只接收来自这些源的事件：

```python
# 只监听来自"Harvester1"和"Harvester2"的energy_full事件
self.listenFor("energy_full", self.on_energy_full, "Harvester1", "Harvester2")

# 使用装饰器方式
@listen("energy_full", "Harvester1", "Harvester2")
def on_energy_full(self, data):
    pass
```

#### 目标过滤

在推送事件时指定 `targets` 参数，只通知这些目标的监听者：

```python
# 只通知名称以"Transporter"开头的监听者
self.pushEvent("energy_full", data, "Transporter")
```

#### 前缀匹配

事件系统使用 `startsWith` 进行源和目标的匹配：

```python
# 监听所有以"Harvester"开头的事件源
self.listenFor("energy_full", self.on_energy_full, "Harvester")

# 这会匹配 "Harvester1", "Harvester2", "HarvesterAlpha" 等
```

### 事件数据格式

事件数据是一个字典或对象，系统自动添加以下字段：

| 字段名 | 类型 | 描述 |
|-------|------|------|
| `inst` | `<named>` | 事件来源，一个包含'name'属性的实例对象 |

**示例**：完整的事件数据结构

```python
# 在HarvesterLogic中触发事件
self.pushEvent("energy_full", {
    "energy_amount": 100,
    "position": Point(10, 20)
})

# 在监听者中接收到的数据格式
{
    "energy_amount": 100,
    "position": Point(10, 20),
    "inst": <HarvesterLogic实例>  # 自动添加
}
```

### 最终代码

以下是一个极简的事件系统使用示例，专注于展示事件的核心功能：

```python
from builtin import *

# 事件发送者
class EventSender(Logic):
    NAME = "Sender"
    
    def onStep(self, creep, k):
        # 每100个tick触发一次事件
        if k.tick % 100 == 0:
            # 触发自定义事件，附带数据
            self.pushEvent("custom_event", {
                "message": "Hello from Sender",
                "tick": k.tick
            })

# 事件接收者
class EventReceiver(Logic):
    NAME = "Receiver"
    
    def onStart(self, creep, k):
        # 监听指定事件，可选择源过滤
        self.listenFor("custom_event", self.on_custom_event, "Sender")
    
    def on_custom_event(self, data):
        # 事件处理逻辑
        print(f"收到事件: {data['message']}, tick: {data['tick']}")
        print(f"事件来源: {data.inst.name}")

# 装饰器使用示例
class DecoratorReceiver(Logic):
    NAME = "DecoratorReceiver"
    
    # 使用@listen装饰器监听事件
    @listen("custom_event")
    def handle_event(self, data):
        print(f"装饰器收到事件: {data['message']}")

# 主逻辑
SPAWN = get.spawn()

def init(k: GlobalKnowledge):
    # 创建实例
    EventSender(SPAWN)
    EventReceiver(SPAWN)
    DecoratorReceiver(SPAWN)

def step(k: GlobalKnowledge):
    pass
```
