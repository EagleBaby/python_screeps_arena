
## 5. 资源存取 (Fetch and Deposit)
  - [资源类型](#资源类型)
  - [获取对象](#获取对象)
  - [能量属性](#能量属性)
  - [拿取资源](#拿取资源)
  - [放置资源](#放置资源)
  - [防御塔](#防御塔)
  - [复合指令:搬运](#复合指令搬运)
  - [编译并运行](#编译并运行)

**目标**：学习如何让 Creep 拿取和放置资源，以及如何使用 Tower 进行防御。

### 资源类型
游戏中存在多种资源类型，最常用的便是`能量`。一个 box (类型为 StructureContainer)、一个spawn (类型为 StructureSpawn) 和带有 `CARRY` 组件的 Creep 可以存储一定数目的任意类型的资源。

| 资源类型 | 描述 |
|---------|------|
| RESOURCE_ENERGY | `能量`，最基础的资源 |
| RESOURCE_??? | 其他类型，不能确定。随游戏版本不同而不同 |

### 获取对象
在本节教程中，游戏为我们提供了如下对象：

| 对象 | 对象类型 | 描述 |
|------|---------|------|
| 友方 Creep | Creep | 带有 Carry 组件，可以搬运资源 |
| 带有 `资源` 的 box | StructureContainer | 内部存放有资源 `资源` |
| 友方 Tower | StructureTower | 消耗自身持有的资源 `能量`，从而向敌人发动攻击 |
| 一圈 Wall | StructureWall | 阻挡 Creep 的移动，对敌我都有效 |
| 敌方 Creep | Creep | 我们需要消灭的目标 |

<details>
<summary>
同先前的教程一样，我们需要先获取这些游戏中的对象。点击展开代码。
</summary>

```python
from builtin import *

CREEP = get.creep(st.friend)
TOWER = get.tower(st.friend)
ENEMY = get.creep(st.enemy)
BOX = get.box()

def init(k: GlobalKnowledge):
    pass


def step(k: GlobalKnowledge):
    pass
```

*需要注意的是，box 并没有敌我之分，至少在游戏的 0.3 版本及以前是这样的。
</details>

### 能量属性
部分游戏对象具有能量相关属性，用于表示其当前能量值、最大能量容量等信息。以下属性适用于：Creep, Source, StructureContainer, StructureSpawn, StructureExtension, StructureTower

| 属性 | 类型 | 描述 |
|------|------|------|
| `energy` | int | 当前能量值 |
| `energyMax` | int | 最大能量容量 |
| `energyPer` | float | 当前能量占最大容量的百分比 |


### 拿取资源
`fetch` 是 `Creep` 类的一个实例方法，构造如下：

| 参数名 | 类型 | 可选 | 默认值 | 描述 |
|--------|------|------|--------|------|
| `target` | `Creep` \| `Resource` \| `Structure` | 否 | - | 目标对象，可以是 `Creep`、`Resource` 或 `Structure` 类型的实例 |
| `resource_type` | `str` \| `None` | 是 | `None` | 要取出的资源类型，默认为 `None`，表示 `RESOURCE_ENERGY` |
| `amount` | `int` \| `None` | 是 | `None` | 取出的资源数量，默认为尽可能多的取出资源 |
| `move` | `bool` \| `UsrObject` | 是 | `True` | 是否启用移动控制，默认为 `True`，表示自动靠近目标 |

| 返回值类型 | 描述 |
|-----------|------|
| `int` | 成功返回 `0`，失败返回小于 `0` 的错误码，详见 `const.py` |

<details>
<summary>
如果我们要从 box 中取出能量，那么我们可以这样写：
</summary>

```python
from builtin import *

CREEP = get.creep(st.friend)
TOWER = get.tower(st.friend)
ENEMY = get.creep(st.enemy)
BOX = get.box()

def init(k: GlobalKnowledge):
    CREEP.fetch(BOX)
    # 等价于
    # CREEP.fetch(BOX, RESOURCE_ENERGY)
    # 等价于
    # CREEP.fetch(BOX, RESOURCE_ENERGY, 50)


def step(k: GlobalKnowledge):
    pass
```
</details>

### 放置资源
`deposit` 是 `Creep` 类的一个实例方法，构造如下：

| 参数名 | 类型 | 可选 | 默认值 | 描述 |
|--------|------|------|--------|------|
| `target` | `None` \| `Point` | 是 | `None` | 目标位置，可以是 `None` 或 `Point` 类型的实例。默认为 `None`，表示丢弃在原地 |
| `resource_type` | `str` \| `None` | 是 | `None` | 要放置的资源类型，默认为 `None`，表示 `RESOURCE_ENERGY` |
| `amount` | `int` \| `None` | 是 | `None` | 放置的资源数量，默认为尽可能多的放置资源 |
| `move` | `bool` \| `UsrObject` | 是 | `True` | 是否启用移动控制，默认为 `True`，表示自动靠近目标 |

| 返回值类型 | 描述 |
|-----------|------|
| `int` | 成功返回 `0`，失败返回小于 `0` 的错误码，详见 `const.py` |

<details>
<summary>
如果我们要将取出的能量放置于 Tower，那么我们可以这样写：
</summary>

```python
from builtin import *

CREEP = get.creep(st.friend)
TOWER = get.tower(st.friend)
ENEMY = get.creep(st.enemy)
BOX = get.box()

def init(k: GlobalKnowledge):
    CREEP.fetch(BOX)  # k.now == 1


def step(k: GlobalKnowledge):
    if k.now == 2:
        CREEP.deposit(TOWER)
        # 等价于
        # CREEP.deposit(TOWER, RESOURCE_ENERGY)
        # 等价于
        # CREEP.deposit(TOWER, RESOURCE_ENERGY, 50)
```
</details>

### 防御塔
Tower 可以对目标进行治疗和攻击，统称为 `Action`。但是每次行动后会有 `10` tick 的冷却时间 (只读属性 `cooldown: int`)，冷却时间归零前，无法进行下一次 `Action` (体现为对应指令的返回值 < 0)。

#### 防御塔：攻击
`tower.attack(target)` 是 `Tower` 类的一个实例方法，构造如下：

| 参数名 | 类型 | 可选 | 默认值 | 描述 |
|--------|------|------|--------|------|
| `target` | `st.hitable` | 否 | - | 目标对象，必须是 `st.hitable` 特征的对象，如 `Structure` 或 `Creep` |

| 返回值类型 | 描述 |
|-----------|------|
| `int` | 成功返回 `0`，失败返回小于 `0` 的错误码，详见 `const.py` |

#### 防御塔：治疗
`tower.heal(target)` 是 `Tower` 类的一个实例方法，构造如下：

| 参数名 | 类型 | 可选 | 默认值 | 描述 |
|--------|------|------|--------|------|
| `target` | `st.hitable` | 否 | - | 目标对象，必须是 `st.hitable` 特征的对象，如 `Structure` 或 `Creep` |

| 返回值类型 | 描述 |
|-----------|------|
| `int` | 成功返回 `0`，失败返回小于 `0` 的错误码，详见 `const.py` |

<details>
<summary>
可以写一段测试代码，便于更好的理解。
</summary>

```python
from builtin import *

CREEP = get.creep(st.friend)
TOWER = get.tower(st.friend)
ENEMY = get.creep(st.enemy)
BOX = get.box()

def init(k: GlobalKnowledge):
    CREEP.fetch(BOX)  # k.now == 1


def step(k: GlobalKnowledge):
    if k.now == 2:
        CREEP.deposit(TOWER)
    
    if TOWER.energy > 0 and TOWER.cooldown <= 0:
        pred_cov = TOWER.measure(CREEP)
        pred_dmg = TOWER.measure(ENEMY)
        print(f"对敌方预估造成伤害{pred_dmg}, 对友方预估治疗{pred_cov}。")
        TOWER.attack(ENEMY)
```

</details>

### 复合指令:搬运
搬运指令 (`carry`) 是 `Creep` 类的一个复合的实例方法，构造如下：

| 参数名 | 类型 | 可选 | 默认值 | 描述 |
|--------|------|------|--------|------|
| `src` | `Structure` \| `Creep` \| `Resource` \| `None` | 否 | - | 资源的来源位置，None 表示使用自身当前已有的资源 |
| `dst` | `Structure` \| `Creep` \| `Point` | 否 | - | 资源的目标位置，Point 表示放置在指定位置 |
| `resource_type` | `str` | 是 | `RESOURCE_ENERGY` | 要搬运的资源类型 |
| `options` | `UsrObject` \| `None` | 是 | `None` | 移动选项。如果为 `None`，则使用默认的移动选项 |

| 返回值类型 | 描述 |
|-----------|------|
| `int` | 成功返回 >= 0，失败返回小于 0 的错误码，详见 `const.py`。完成一轮搬运时，返回 `DONE` (值为 `1`) |

<details>
<summary>
所以你可以使用<b>carry</b>来替换<b>fetch</b>和<b>deposit</b>, 可以简化代码。
</summary>

```python
from builtin import *

CREEP = get.creep(st.friend)
TOWER = get.tower(st.friend)
ENEMY = get.creep(st.enemy)
BOX = get.box()

def init(k: GlobalKnowledge):
    pass


def step(k: GlobalKnowledge):
    CREEP.carry(BOX, TOWER)
    TOWER.attack(ENEMY)  # 失败会返回错误码，只是此处我们不关心。
```

</details>
