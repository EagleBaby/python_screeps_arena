## 10+.最终测试(面向对象)
  - [防守反击策略](#防守反击策略)
  - [最终代码](#最终代码)

本节教程将介绍最终测试的进阶策略，使用逻辑引擎（CreepLogic）来实现更模块化、更可维护的代码结构。

### 防守反击策略

我们将使用CreepLogic来实现防守反击策略，该策略注重防御工事的建设，通过修筑城防来抵御敌人的进攻，同时发展自己的反击力量。

### 最终代码

#### 背景代码
```python
from builtin import *

SPAWN = get.spawn()
SOURCE = get.source()
ENEMIES = get.creeps(st.enemy)

SP = SitePlaner(
    SitePlan(SPAWN, 0, 0, StructureRampart),
    SitePlan(SPAWN, 0, -1, StructureRampart),
    SitePlan(SPAWN, 0, 1, StructureRampart),
)
```

#### Worker逻辑
```python
class WorkerType(CreepLogic):
    NAME = "worker"
    RECIPE = [MOVE, CARRY, WORK, WORK, WORK, WORK]

    def building(self, c: Creep, k: GlobalKnowledge, *childern: Logic):
        if c.energy < 20:
            c.harvest(SOURCE)
        else:
            site = SP.next()
            
            if st.na(site):
                return "harvesting"
            
            c.build(site)
    
    def harvesting(self, c):
        c.harvest(SOURCE)

    def onChanged(self, src: str, dst: str, k: GlobalKnowledge, *childern: Logic):
        self.link("bridge")
```

#### Bridge逻辑
```python
class BridgeType(CreepLogic):
    NAME = "bridge"
    RECIPE = [CARRY]
    DIRECTION = RIGHT

    def onStep(self, c: Creep, k: GlobalKnowledge, *childern: Logic):
        work_cl: WorkerType = self.parent

        if not work_cl.ready:
            return

        if c.energy:
            c.deposit(SPAWN)
        else:
            c.fetch(work_cl.c)
```

#### Defender逻辑
```python
class DefenderA(CreepLogic):
    NAME = "defenderA"
    RECIPE = [RANGED_ATTACK, ATTACK, RANGED_ATTACK, ATTACK]
    DIRECTION = TOP

    def onStep(self, c: Creep):
        e = c.closest(ENEMIES)

        if st.na(e):
            return

        c.attack(e)
            

class DefenderB(DefenderA):
    DIRECTION = BOTTOM
```

#### 初始化逻辑
```python
def init(k: GlobalKnowledge):
    CreepLogic("worker", SPAWN)
    CreepLogic("defenderA", SPAWN)
    CreepLogic("defenderB", SPAWN)


def step(k: GlobalKnowledge):
    CreepLogic.showQueue()
```

#### 实现说明
1. **WorkerType**：负责采集能量和修筑城防，包含两个状态：
   - `building`状态：修筑城防直到完成
   - `harvesting`状态：持续采集能量
   - 状态切换时自动创建BridgeType实例

2. **BridgeType**：负责在Worker和Spawn之间传递能量
   - 检测Worker状态，自动往返传递能量

3. **DefenderA/DefenderB**：负责防御和反击敌人
   - 自动索敌并攻击最近的敌人
   - DefenderB继承自DefenderA，仅方向不同

4. **初始化逻辑**：
   - 在init中创建各个CreepLogic实例
   - 在step中展示生产队列

这种基于逻辑引擎的实现方式更加模块化、可维护，并且充分利用了状态机的特性来管理复杂的游戏逻辑。