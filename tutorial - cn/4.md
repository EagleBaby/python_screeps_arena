## 4. Creep的构成
  - [组件类型](#组件类型)
  - [组件顺序](#组件顺序)
  - [能力筛选与检视](#能力筛选与检视)
  - [指令冲突](#指令冲突)
  - [治疗指令](#治疗指令)
  - [最终代码](#最终代码)

**目标**：了解Creep的身体组件构成，根据组件区分Creep能力。

### 组件类型
**每个组件提供100点生命值**，功能如下：

| 组件名 | 行动类别 | 价格 | 描述 |
|-------|---------|------|------|
| MOVE | 其他 | 50 | 每tick降低fatigue值2点，无MOVE组件不可以移动 |
| CARRY | 资源 | 50 | 提供50点资源容量，有资源时产生移动疲劳 |
| ATTACK | 近程 | 80 | 30点近战伤害，攻击距离1 |
| RANGED_ATTACK | 远程 | 150 | 10点远程伤害，攻击距离3，可造成AOE伤害 |
| HEAL | 近程/远程 | 250 | 近程12点治疗，远程4点治疗，距离3 |
| WORK | 近程(采集)/远程(建造) | 100 | 建造速度5/ tick，采集能量2/ tick |
| TOUGH | 其他 | 10 | 仅提供生命值，无特殊功能 |

**远程AOE伤害**：
| 距离 | 伤害 |
|------|------|
| 1 | 10 |
| 2 | 4 |
| 3 | 1 |

远程攻击根据到目标的距离自动选择AOE还是普通模式。

### 组件顺序
**伤害优先顺序**：从左到右依次承受伤害
**治疗优先顺序**：从右到左依次接受治疗

**示例**：
- `[ATTACK, MOVE]` - 受伤时先损失攻击能力
- `[MOVE, ATTACK]` - 受伤时先损失移动能力

### 能力筛选与检视
**使用`st`模块筛选Creep**：
```python
from builtin import *

# 获取不同类型的友方Creep, tuple表示`与`逻辑
WORRIER = get.creep( (st.friend, st.melee) )    # 近战
RANGER = get.creep( (st.friend, st.ranged) )    # 远程
HEALER = get.creep( (st.friend, st.healable) ) # 治疗
ENEMY = get.creep(st.enemy)                  # 敌方
```

**检视Creep能力**：
```python
def init(k: GlobalKnowledge):
    print("简略信息:", WORRIER.info)
    print("详细信息:", WORRIER.info.details())
```

### 指令冲突
**行动类别**：资源、近程、远程
**规则**：同一tick内，同类型指令会被后执行的覆盖

- 近战攻击 ❌ 近程治疗
- 远程攻击 ❌ 远程治疗
- 远程攻击 ❌ 建造

- 远程攻击 ✅ 近战治疗 
- 远程攻击 ✅ 采集 

### 治疗指令
`creep.heal(target: Creep, move: MotionOptions | bool = True) -> int`

| 参数名 | 类型 | 可选 | 默认值 | 描述 |
|-------|------|------|--------|------|
| `target` | `Creep` | 否 | - | 治疗目标（可为自身） |
| `move` | `MotionOptions` \| `bool` | 是 | `True` | 移动控制参数，如果传入`False`，表明禁用移动 |

**返回值**：
- `OK` (0): 操作已成功安排
- `ERR_NOT_OWNER` (-1): 你不是该creep的拥有者
- `ERR_INVALID_TARGET` (-7): 目标不是有效的creep对象
- `ERR_NOT_IN_RANGE` (-9): 目标太远
- `ERR_NO_BODYPART` (-12): creep的身体中没有HEAL部件

**说明**：根据距离自动选择近程/远程治疗，禁用移动可避免指令冲突。

### 最终代码
```python
from builtin import *

WORRIER = get.creep( (st.friend, st.melee) )
RANGER = get.creep( (st.friend, st.ranged) )
HEALER = get.creep( (st.friend, st.healable) )
ENEMY = get.creep(st.enemy)

def init(k: GlobalKnowledge):
    pass

def step(k: GlobalKnowledge):
    # 攻击指令
    WORRIER.attack(ENEMY)
    RANGER.attack(ENEMY)
    # 治疗指令（禁用自动移动）
    HEALER.heal(WORRIER, False)
    HEALER.move(WORRIER)  # 手动移动
```

