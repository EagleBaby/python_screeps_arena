## 5. Resource Fetch and Deposit
  - [Resource Types](#resource-types)
  - [Acquiring Objects](#acquiring-objects)
  - [Energy Properties](#energy-properties)
  - [Fetch Resources](#fetch-resources)
  - [Deposit Resources](#deposit-resources)
  - [Defense Tower](#defense-tower)
  - [Composite Command: Carry](#composite-command-carry)
  - [Compile and Run](#compile-and-run)

**Objective**: Learn how to make Creeps fetch and deposit resources, and how to use Tower for defense.

### Resource Types
There are multiple resource types in the game, the most commonly used is `energy`. A box (StructureContainer), a spawn (StructureSpawn), and Creeps with `CARRY` parts can store a certain amount of any type of resource.

| Resource Type | Description |
|--------------|-------------|
| RESOURCE_ENERGY | `energy`, most basic resource |
| RESOURCE_??? | Other types, uncertain. Varies with game version |

### Acquiring Objects
In this tutorial, the game provides the following objects:

| Object | Object Type | Description |
|--------|-------------|-------------|
| Friendly Creep | Creep | With Carry part, can carry resources |
| Box with `resource` | StructureContainer | Contains resource `resource` |
| Friendly Tower | StructureTower | Consumes its own `energy` to attack enemies |
| Ring of Wall | StructureWall | Blocks Creep movement, effective for both sides |
| Enemy Creep | Creep | Target we need to eliminate |

<details>
<summary>
Like previous tutorials, we need to first acquire these game objects. Click to expand code.
</summary>

```python
from builtin import *

CREEP = get.creep(st.friend)
TOWER = get.tower(st.friend)
ENEMY = get.creep(st.enemy)
BOX = get.box()

def init(k: GlobalKnowledge):
    pass


def step(k: GlobalKnowledge):
    pass
```

*Note: box has no friend/enemy distinction, at least in game version 0.3 and earlier.
</details>

### Energy Properties
Some game objects have energy-related properties indicating current energy, maximum capacity, etc. These properties apply to: Creep, Source, StructureContainer, StructureSpawn, StructureExtension, StructureTower

| Property | Type | Description |
|----------|------|-------------|
| `energy` | int | Current energy value |
| `energyMax` | int | Maximum energy capacity |
| `energyPer` | float | Current energy as percentage of maximum capacity |


### Fetch Resources
`fetch` is an instance method of `Creep` class, constructed as:

| Parameter Name | Type | Optional | Default Value | Description |
|--------------|------|----------|---------------|-------------|
| `target` | `Creep` \| `Resource` \| `Structure` | No | - | Target object, can be instance of `Creep`, `Resource`, or `Structure` |
| `resource_type` | `str` \| `None` | Yes | `None` | Resource type to fetch, default `None` means `RESOURCE_ENERGY` |
| `amount` | `int` \| `None` | Yes | `None` | Amount to fetch, default `None` means fetch as much as possible |
| `move` | `bool` \| `UsrObject` | Yes | `True` | Enable movement control, default `True` means automatically approach target |

| Return Value Type | Description |
|------------------|-------------|
| `int` | Success returns `0`, failure returns error code < `0`, see `const.py` |

<details>
<summary>
To fetch energy from box, we can write:
</summary>

```python
from builtin import *

CREEP = get.creep(st.friend)
TOWER = get.tower(st.friend)
ENEMY = get.creep(st.enemy)
BOX = get.box()

def init(k: GlobalKnowledge):
    CREEP.fetch(BOX)
    # Equivalent to
    # CREEP.fetch(BOX, RESOURCE_ENERGY)
    # Equivalent to
    # CREEP.fetch(BOX, RESOURCE_ENERGY, 50)


def step(k: GlobalKnowledge):
    pass
```
</details>

### Deposit Resources
`deposit` is an instance method of `Creep` class, constructed as:

| Parameter Name | Type | Optional | Default Value | Description |
|--------------|------|----------|---------------|-------------|
| `target` | `None` \| `Point` | Yes | `None` | Target position, can be `None` or `Point` instance. Default `None` means drop at current location |
| `resource_type` | `str` \| `None` | Yes | `None` | Resource type to deposit, default `None` means `RESOURCE_ENERGY` |
| `amount` | `int` \| `None` | Yes | `None` | Amount to deposit, default `None` means deposit as much as possible |
| `move` | `bool` \| `UsrObject` | Yes | `True` | Enable movement control, default `True` means automatically approach target |

| Return Value Type | Description |
|------------------|-------------|
| `int` | Success returns `0`, failure returns error code < `0`, see `const.py` |

<details>
<summary>
To deposit fetched energy into Tower, we can write:
</summary>

```python
from builtin import *

CREEP = get.creep(st.friend)
TOWER = get.tower(st.friend)
ENEMY = get.creep(st.enemy)
BOX = get.box()

def init(k: GlobalKnowledge):
    CREEP.fetch(BOX)  # k.now == 1


def step(k: GlobalKnowledge):
    if k.now == 2:
        CREEP.deposit(TOWER)
        # Equivalent to
        # CREEP.deposit(TOWER, RESOURCE_ENERGY)
        # Equivalent to
        # CREEP.deposit(TOWER, RESOURCE_ENERGY, 50)
```
</details>

### Defense Tower
Tower can heal and attack targets, collectively called `Action`. But after each action there's a `10` tick cooldown (read-only property `cooldown: int`). Before cooldown reaches zero, cannot perform next `Action` (command returns value < 0).

#### Tower: Attack
`tower.attack(target)` is an instance method of `Tower` class, constructed as:

| Parameter Name | Type | Optional | Default Value | Description |
|--------------|------|----------|---------------|-------------|
| `target` | `st.hitable` | No | - | Target object, must be `st.hitable` object like `Structure` or `Creep` |

| Return Value Type | Description |
|------------------|-------------|
| `int` | Success returns `0`, failure returns error code < `0`, see `const.py` |

#### Tower: Heal
`tower.heal(target)` is an instance method of `Tower` class, constructed as:

| Parameter Name | Type | Optional | Default Value | Description |
|--------------|-------|----------|---------------|-------------|
| `target` | `st.hitable` | No | - | Target object, must be `st.hitable` object like `Structure` or `Creep` |

| Return Value Type | Description |
|------------------|-------------|
| `int` | Success returns `0`, failure returns error code < `0`, see `const.py` |

<details>
<summary>
Write test code to better understand.
</summary>

```python
from builtin import *

CREEP = get.creep(st.friend)
TOWER = get.tower(st.friend)
ENEMY = get.creep(st.enemy)
BOX = get.box()

def init(k: GlobalKnowledge):
    CREEP.fetch(BOX)  # k.now == 1


def step(k: GlobalKnowledge):
    if k.now == 2:
        CREEP.deposit(TOWER)

    if TOWER.energy > 0 and TOWER.cooldown <= 0:
        pred_cov = TOWER.measure(CREEP)
        pred_dmg = TOWER.measure(ENEMY)
        print(f"Estimated damage to enemy{pred_dmg}, estimated heal to friendly{pred_cov}.")
        TOWER.attack(ENEMY)
```

</details>

### Composite Command: Carry
Carry command (`carry`) is a composite instance method of `Creep` class, constructed as:

| Parameter Name | Type | Optional | Default Value | Description |
|-------------|------|----------|---------------|-------------|
| `src` | `Structure` \| `Creep` \| `Resource` \| `None` | No | - | Resource source location, None means use current resources |
| `dst` | `Structure` \| `Creep` \| `Point` | No | - | Resource destination, Point means drop at specified location |
| `resource_type` | `str` | Yes | `RESOURCE_ENERGY` | Resource type to carry |
| `options` | `UsrObject` \| `None` | Yes | `None` | Movement options. If `None`, use default motion options |

| Return Value Type | Description |
|------------------|-------------|
| `int` | Success returns >= 0, failure returns error code < 0, see `const.py`. Returns `DONE` (value `1`) when completing a round |

<details>
<summary>
So you can use **carry** to replace **fetch** and **deposit**, simplifying code.
</summary>

```python
from builtin import *

CREEP = get.creep(st.friend)
TOWER = get.tower(st.friend)
ENEMY = get.creep(st.enemy)
BOX = get.box()

def init(k: GlobalKnowledge):
    pass


def step(k: GlobalKnowledge):
    CREEP.carry(BOX, TOWER)
    TOWER.attack(ENEMY)  # Failure returns error code, but we don't care here.
```

</details>

### Compile and Run
Configure `build.py` by first opening the file for Tutorial 1 in the game using the `External Editor` (click the filename above `Play Game`). In the opened VSCode, right-click `main.mjs` to get its file path, then paste it into the `config.target` value in `build.py` (uncomment it if necessary).

Set the language in `config.language` to `'en'` (English output) or `'cn'` (partially Chinese output).

Run `build.py` in PyCharm to transpile Python to JavaScript. If successful, click `Play Game` to see the result and receive a `Pass` popup.
