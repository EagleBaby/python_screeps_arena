## 8+. Harvesting Energy (Object-Oriented)
  - [State Nodes](#state-nodes)
  - [State Pattern](#state-pattern)
  - [Final Code](#final-code)

This section introduces how to implement energy harvesting logic equivalent to 8.md using state nodes and state patterns of the `CreepLogic` class. This is a more structured and maintainable approach.

### State Nodes

`CreepLogic` inherits from the `Stage` class, thus it has the functionality of a `Finite Behavior-State Machine` (FBM), or simply `behavior machine`. Its core is state nodes, where each state node is a method that switches states through return values.
* This example only considers its state machine functionality, not its behavior tree functionality

```python
from builtin import *

class Demo(Stage):
    NAME = "Demo"

    def state0(self, it: any, k: GlobalKnowledge):
        return "state1"

    def state1(self):
        return "idle"

    def idle(self):
        return  # Keep current state

    def _state2(self):
        pass  # Starts with _, not a state node
```

| State Node Characteristics | Description |
|------------|------|
| Naming Rule | Method name cannot start with `_` |
| Initial State | The first defined state node |
| State Switching | Achieved by returning the state node name string |
| Keep State | Return the current state node name string |

### State Pattern

`Logic` and its subclasses can automatically execute `behavior machines`. The execution order relative to other methods is as follows:

- main.py's `step` method
- Execute `state nodes`
- `onStep` method

In Tutorial 8, two states are needed:
- Harvest state, harvest energy from Source
- Deposit state, store energy to Spawn

#### Harvest State
```python
def harvest_state(self, creep: Creep, k: GlobalKnowledge):
    """Harvest state - corresponds to harvest logic in 8.md"""
    # Execute harvest operation
    creep.harvest(SOURCE)
    # Check if energy is full
    if creep.energy >= creep.energyMax:
        # Energy full, switch to deposit state
        return "deposit_state"
    # Energy not full, continue harvest state (return None)
```

#### Deposit State
```python
def deposit_state(self, creep: Creep, k: GlobalKnowledge):
    """Deposit state - corresponds to deposit logic in 8.md"""
    # Execute deposit operation
    if creep.carry(None, SPAWN) is DONE:
        # Carry completed, switch to harvest state
        return "harvest_state"
```

### Final Code
```python
from builtin import *

SPAWN = get.spawn()
CREEP = get.creep()
SOURCE = get.source()

class WorkerCreep(CreepLogic):
    NAME = "Worker"  # Creep logic name

    def harvest_state(self, creep: Creep, k: GlobalKnowledge):
        creep.harvest(SOURCE)
        if creep.energy >= creep.energyMax:
            return "deposit_state"

    def deposit_state(self, creep: Creep, k: GlobalKnowledge):
        if creep.carry(None, SPAWN) is DONE:
            return "harvest_state"

def init(k: GlobalKnowledge):
    Logic("Worker", CREEP)

def step(k: GlobalKnowledge):
    pass
```
