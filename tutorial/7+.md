## 7+. Creating New Creeps (Object-Oriented)
  - [CreepLogic Class Introduction](#creeplogic-class-introduction)
  - [Creating Behavior](#creating-behavior)
  - [Step Callback](#step-callback)
  - [Instantiation Method](#instantiation-method)
  - [Final Code](#final-code)

This section introduces how to create and manage creeps through inheriting the `CreepLogic` class. This is an object-oriented, more structured and maintainable approach with powerful logic control capabilities. This section starts with the basics.

### CreepLogic Class Introduction

`CreepLogic` is the base class for creep logic, with inheritance chain `...->Stage->Logic->CreepLogic`, providing a series of attributes and methods related to creep creation and management. By inheriting `CreepLogic`, you can more conveniently define the behavior and attributes of creeps.

### Creating Behavior

By setting the following main class variables, you can control the creep creation behavior:

| Class Variable | Type | Default Value | Description |
|-------|------|-------|------|
| `NAME` | `str` | - | Creep logic name, type identifier when creating creeps. Cannot end with a number. |
| `RECIPE` | `list[str]` \| `str` | `[MOVE]` or `M1` | Creep recipe, defines the body parts of the creep |
| `OPTIMISE` | `bool` \| `int` \| `None` | `True` | Whether to automatically optimize recipe order to improve functional survivability |
| `DIRECTION` | `int` | `None` | Creep spawn direction, such as LEFT, RIGHT, TOP, etc. |

### Step Callback

The `CreepLogic` class provides the `onStep` callback method, which you can override to define the creep's behavior. The `onStep` callback of all logic classes is executed after the `step` method of `main.py`.

Function signature of `onStep` method:

| Parameter Name | Type | Optional | Default Value | Description |
|-------|------|------|--------|------|
| `c` | `Creep` | No | - | Creep instance |
| `k` | `GlobalKnowledge` | No | - | GlobalKnowledge global knowledge |
| `*refs` | `CreepLogic` | Yes | - | Child instances created by link |

*Note: Since it runs in JS environment, you can fold unwanted parameters:
```python
def onStep(self):  # Won't cause errors
    """Logic executed every tick"""
    pass
```

### Instantiation Method

There are three ways to instantiate creep logic:

| Instantiation Method | Description | Example |
|-----------|------|------|
| `Logic("Mover", SPAWN)` | Pass logic name and parameters through base class `Logic` | `Logic("Mover", get.spawn())` |
| `CreepLogic("Mover", SPAWN)` | Pass logic name and parameters through base class `CreepLogic` | `CreepLogic("Mover", get.spawn())` |
| `MoverCreep(SPAWN)` | Directly use specific subclass and pass parameters | `MoverCreep(get.spawn())` |

**Implementation Principle**:
- `CreepLogic` implements the factory pattern using Logic class's `__new__` method
- When the first parameter is a string, it finds the corresponding prototype class through `StageMachineLogicMeta.proto()`
- Then uses this prototype class to create an instance and passes remaining parameters

### Final Code

Below is a complete example of creating a creep that moves to a flag:

```python
from builtin import *

class MoverCreep(CreepLogic):
    """Creep logic that moves to flag"""
    NAME = "Mover"  # Creep logic name
    RECIPE = [MOVE]  # Creep recipe, contains only move part

    def onStep(self, creep: Creep, k: GlobalKnowledge):
        """Logic executed every tick"""
        # Determine which flag to move to based on uid
        creep.move(FLAGS[self.uid % 2])  # uid starts from 1

SPAWN = get.spawn()
FLAGS = get.flags()

def init(k: GlobalKnowledge):
    """Initialization function"""
    # Create two MoverCreep instances, both methods are equivalent
    Logic("Mover", SPAWN)
    MoverCreep(SPAWN)

def step(k: GlobalKnowledge):
    """Logic executed every tick"""
    pass
```
