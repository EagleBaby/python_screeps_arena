## 10+. Final Test (Object-Oriented)
  - [Defensive Counterattack Strategy](#defensive-counterattack-strategy)
  - [Final Code](#final-code)

This section introduces the advanced strategy for the final test, using the logic engine (CreepLogic) to achieve a more modular and maintainable code structure.

### Defensive Counterattack Strategy

We'll use CreepLogic to implement a defensive counterattack strategy, focusing on building defensive structures to resist enemy attacks while developing one's own counterattack power.

### Final Code

#### Background Code
```python
from builtin import *

SPAWN = get.spawn()
SOURCE = get.source()
ENEMIES = get.creeps(st.enemy)

SP = SitePlaner(
    SitePlan(SPAWN, 0, 0, StructureRampart),
    SitePlan(SPAWN, 0, -1, StructureRampart),
    SitePlan(SPAWN, 0, 1, StructureRampart),
)
```

#### Worker Logic
```python
class WorkerType(CreepLogic):
    NAME = "worker"
    RECIPE = [MOVE, CARRY, WORK, WORK, WORK, WORK]

    def building(self, c: Creep, k: GlobalKnowledge, *childern: Logic):
        if c.energy < 20:
            c.harvest(SOURCE)
        else:
            site = SP.next()

            if st.na(site):
                return "harvesting"

            c.build(site)

    def harvesting(self, c):
        c.harvest(SOURCE)

    def onChanged(self, src: str, dst: str, k: GlobalKnowledge, *childern: Logic):
        self.link("bridge")
```

#### Bridge Logic
```python
class BridgeType(CreepLogic):
    NAME = "bridge"
    RECIPE = [CARRY]
    DIRECTION = RIGHT

    def onStep(self, c: Creep, k: GlobalKnowledge, *childern: Logic):
        work_cl: WorkerType = self.parent

        if not work_cl.ready:
            return

        if c.energy:
            c.deposit(SPAWN)
        else:
            c.fetch(work_cl.c)
```

#### Defender Logic
```python
class DefenderA(CreepLogic):
    NAME = "defenderA"
    RECIPE = [RANGED_ATTACK, ATTACK, RANGED_ATTACK, ATTACK]
    DIRECTION = TOP

    def onStep(self, c: Creep):
        e = c.closest(ENEMIES)

        if st.na(e):
            return

        c.attack(e)


class DefenderB(DefenderA):
    DIRECTION = BOTTOM
```

#### Initialization Logic
```python
def init(k: GlobalKnowledge):
    CreepLogic("worker", SPAWN)
    CreepLogic("defenderA", SPAWN)
    CreepLogic("defenderB", SPAWN)


def step(k: GlobalKnowledge):
    CreepLogic.showQueue()
```

#### Implementation Notes
1. **WorkerType**: Responsible for harvesting energy and building defenses, includes two states:
   - `building` state: Build defenses until completed
   - `harvesting` state: Continuously harvest energy
   - Automatically creates BridgeType instance when switching states

2. **BridgeType**: Responsible for transferring energy between Worker and Spawn
   - Detects Worker status and automatically transfers energy back and forth

3. **DefenderA/DefenderB**: Responsible for defending and counterattacking enemies
   - Automatically searches for and attacks the nearest enemy
   - DefenderB inherits from DefenderA, only direction is different

4. **Initialization Logic**:
   - Create each CreepLogic instance in init
   - Display production queue in step

This logic engine-based implementation is more modular, maintainable, and fully utilizes state machine features to manage complex game logic.
